\newpage
\safeoldsection[Кэширование информации интерпретатора]{Кэширование информации\newline интерпретатора}

Обращение к памяти на стеке для чтения или записи является долгой операцией, поэтому необходимо уменьшать количество таких обращений. В процессе работы интерпретатора идёт частое обращение к одним и тем же данным, которые лежат где-то в памяти, и такие данные (или адреса, указывающие на них) можно положить в специальные регистры, значения в которых не будут портиться при вызовах C функций, так как по общему соглашению значения этих регистров должно быть одинаковым до и после вызова функции, а потому их называют неизменяемыми.

Всего в архитектуре RISC-V 12 неизменяемых регистров, один из которых используется, как fp регистр. В итоге получается 11 регистров, которые можно использовать под свои нужды. На каждой архитектуре разное количество этих регистров, на PowerPC их 18, и в RISC-V не хватает регистров, чтобы закэшировать всю информацию, что кэшируется в PowerPC, а потому было решено провести исследование со сбором статистики использования данных регистров, чтобы выбрать наиболее необходимые.



\subsection{Выбор источников для сбора статистики}

Сбор статистики должен производиться из объективных источников, чтобы реальные пользователи OpenJDK смогли ощутить схожий с полученными данными прирост производительности. Таким образом, было выбрано 3 основных источника.
Первый - инициализация JVM, которая происходит при каждом запуске Java приложений, и, что не менее важно, основная его работа происходит без использования JIT компиляции, так как для её активации ещё не хватает собранной статистики из-за ранних этапов работы JVM, и это делает данные замеры ещё более объективными.
Второй источник - Renaissance Suite \cite{renaissance}, тест производительности, основанный на реальных приложениях, использующий в своих тестах библиотеки scala, spark и прочие жизненные примеры использования JVM, данный тест является новым, объемным и широко распространенным.
Третий источник - SPECjvm2008, это первый, популярный в свое время, тест производительности Java, основанный на реальных приложениях.

Одной из задач данной работы было создание универсальных полуавтоматических инструментов, позволяющих получать данные из любых источников, что могло бы значительно ускорить работу по корректировке и перепроверке результатов, поэтому рассмотренные источники могут быть дополнены в будущем, а цель текущего их выбора состоит в базовой проверке гипотез и получения начальных объективных, но не обязательно полных, данных. 



\subsection{Ручной сбор статистики}

Первой идеей сбора данных был ручной подсчет использования регистров в байткодах, а далее, используя статистику по количеству исполненных байткодов, можно было бы получить общую статистику по количеству использования регистров в порте. Статистику по исполнению байткодов можно получить с помощью встроенных инструментов OpenJDK, а в связи с тем, что генерация байткодов не зависит от платформы, собрать её можно на архитектуре x86\_64. Целью данного сбора было выявление сильноиспользуемых и малоиспользуемых регистров, которые уже кэширует информацию в PowerPC порте, и, в большинстве своем, в RISC-V. Данные собирались по ещё недописанному порту RISC-V, однако, на момент сбора статистики, в нём было реализовано уже порядка 80 процентов байткодов, остальные же брались с PowerPC из предположения, что используемые данные на разных портах не сильно различаются, потому что абстрактное состояние интерпретации и байткоды не зависят от архитектуры.

В итоге хотелось получить количество обращений к памяти к каждому полю, если бы оно не было закэшировано, что означает, что простым подсчетом количества использований обойтись не получится, так как можно загрузить данные во временный регистр один раз и потом обращаться к ним много раз во время интерпретации байткода. Автоматический сбор таких данных тоже маловозможен, преимущественно из-за очень сложной интерпретации измененния данных. Автоматически нельзя понять, после каких изменений данные необходимо записать в память, а какие изменения можно расчитывать во временных регистрах. Также все временные регистры теряют информацию после каждого Runtime вызова, что тоже усложняет расчеты. В дополнение к этому, иногда можно изменить сигнатуру некоторых функций, что позволит передавать значения регистров внутрь и избавит от лишнего взятия этих данных внутри функции, если было необходимо взять их ещё и снаружи. И что не менее существенно, целью было произвести подсчет для порта RISC-V, а он ещё находится в состоянии разработки, и не может полностью обработать вычисления из выбранных источников. 

Все наложенные ограничения привели к необходимости производить подсчет вручную, а именно, посчитать приближенное количество загрузок и сохранения данных для каждого значения, если бы оно не было сохранено в регистр. Всего в OpenJDK 251 байткод, за реализацию которых отвечает 128 методов, для каждого из которых, а также множества вызванных вспомогательных методов, была подсчитана искомая информация. Все полученные результаты были занесены в таблицу, а также были настроены формулы по автоматическому пересчету значений, позволяющие, в конечном счете, загрузить в таблицы статистику по исполнению байткодов и автоматически получить статистику по использованию данных.

Данный подсчет не учитывает код, вызываемый на момент создания фреймов, или же код, переключающий байткоды, потому что эти данные сложнее получить без существенных модификаций порта x86\_64, на котором осуществлялся сбор статистики по исполнению байткодов. Однако некоторые изменения пришлось внести в связи с тем, что счетчики байткодов переполнялись при анализе Renaissance Suite, поэтому необходимо было сделать модификации для подсчета статистики в 64-битных значениях.



\subsection{Автоматический сбор статистики}

После проведения ручного сбора статистики появилась необходимость провести более подробный анализ данных, чтобы посчитать не только использование уже закэшированных данных, но и данных, которые потенциально можно было бы закэшировать, а также провести проверку данных, в связи с возможными ошибками при ручном подсчете. Поскольку заранее были неизвестны все данные, которые необходимо посчитать, а также была потребность в возможности не учитывать какие-то данные, либо добавлять новые по ходу исследования, то ручной сбор уже не подходил, но и проблемы автоматического не исчезли. Идеальной архитектурой для данного сбора был бы порт, у которого было бы бесконечное количество временных регистров, и ни одного неизменяемого, чтобы каждый раз обращение к данным происходило через память, но чтобы данные сохранялись во временных регистрах и использовались через них, пока это возможно. Такого порта не существует, однако архитектура x86\_64 наиболее близка к подобному, и имея посчитанную вручную статистику для немногих закэшированных на ней данных, можно было бы собрать автоматическую статистику на всех остальных. 

Данный подход потребовал переписать сотни обращений к памяти, проинструментировать их для сбора статистики, что оказалось долгой и непростой задачей. Также была выявлена проблема интерпретации получаемых данных, так как все нетривиальные зависимости и условности при использовании данных, которые были посчитаны вручную, теперь не учитывались, и необходимо было как-то это автоматизировать, что сделать полностью было невозможно. Из-за сильной иерархичности доступа к данным была добавлена возможность вести подсчет без учета доставаемых предков в иерархии доступа, например, если в структуре method лежит структура constMethod, а в ней cachePool, то, при загрузке всех трех полей последовательно, в статистике будет учтена только загрузка cachePool. Подобные усложнения помогли избавиться от некоторых проблем с интерпретацией данных, однако породили сильные зависимости между собранными данными и усложнили общий подход к их интерпретации. Также, из-за обозначенной выше невозможности автоматического учитывания всего контекста вычислений, для правильной интерпретации данных периодически необходимо анализировать код, чтобы их понять, например, если загружается три разных поля из структуры constMethod примерно одинаковое количество раз, без анализа кода невозможно сказать, нужно ли все эти три раза грузить constMethod, или они все грузятся после того, как constMethod был загружен в другой временный регистр. Ещё большую путаницу вводит то, что на x86\_64 количество временных регистров не бесконечно и сильно меньше, чем у RISC-V, поэтому периодически данные грузятся по несколько раз, где в RISC-V можно было бы загружать их только один.

Все перечисленные факторы существенно замедлили процесс анализа данных, что, в совокупности с общим объемом работы и возникающими непредвиденными трудностями в процессе инструментирования обращений, не позволило провести расчеты для всех данных, использующихся в порте. Часть данных была выбрана из соображений проверки ручного сбора данных, остальные были выбраны из представления о частоте их использования по количеству их встречаемости в коде.



\subsection{Обработка результатов}

Для обработки результатов с первого метода были использованы флаги OpenJDK \textit{PrintBytecodeHistogram} и \textit{ActiveProcessorCount=1}, чтобы распечатать статистику по выполненным байткодам и сделать исполнение кода на одном процессе, иначе подсчет статистики будет собираться некорректно. Для запуска Renaissance Suite использовались параметры \textit{\texttt{--}functional\texttt{-}test \texttt{-}r 1 all}, а для SPECjvm2008 \textit{\texttt{-}mi 1 \texttt{-}ma 1 \texttt{-}bt 1 \texttt{-}ikv}.

Всего в инициализации JVM было исполнено 48 миллионов байткодов, в Renaissance Suite 225.7 миллиардов, а в SPECjvm2008 628.7 миллионов. По данным ручного сбора, распределения по использованию данных (в процентах от их общего числа) при инициализации JVM и в Renaissance Suite близки друг к другу, в SPECjvm2008 ситуация отличается некритично, там выше процент использования локалов и указателя на байткод, что обусловлено большим процентом математических и околоматематических байткодов, которые много оперируют со стеком и данным указателем.

С помощью автоматического подсчета удалось найти и исправить некоторые ошибки ручного тестирования, после исправления которых можно наблюдать данный результат на инициализации VM: регистры указателя на байткод (bcp), текущего потока (threads), локалов (locals), верхушки стека вычислений (TOS) и начала фрейма (fp) используются десятки миллионов раз. Автоматически собранная статиста показывает, что таблица диспетчеризации (dispatch\_table) используется 48 миллионов раз, в ручном сборе она используется ноль раз, ибо отрабатывает только в исключительных случаях, которые не учитывались. Данная разница просто объясняется тем, что данное значение используется при переходе между байткодами и не учитывается в ручном подсчете. Также в ручном подсчете не полностью учитывается указатель на стек вычислений (esp), 7 миллионов в ручном сборе и более 58 при автоматическом. Данное отличие обусловлено изменением значения данного регистра между байткодами, а из-за частой изменяемости значения, при каждом обращении нужно делать и загрузку, и сохранение в память, что удваивает количество обращений к памяти. Указатель на конец предыдущего фрейма (sender\_sp) используется только при возврате из метода, которых было около 2.5 миллионов, и надобность в данном кэшировании минимальна. Регистр таблицы содержания (TOC) в шаблонном интерпретаторе не используется в принципе, он нужен только для JIT компиляции, а значит можно в будущем заменить его на регистр, не использующийся в JIT компиляции, например locals. Регистр мониторов (monitors) показывает также крайне низкие показатели - почти 6 тысяч в ручном тестировании и 112 в автоматическом. Данная разница сильно проявляется из-за неучтенных в ручном тестировании вызовов синхронизированных методов, которые прибавляют 106 тысяч использований. Данный регистр является самым неоднозначным из всех вышеперечисленных, так как его использование очень сильно зависит от специфики приложений, и сбор статистики не был осуществлен в многопоточном режиме, поэтому в будущем необходимо найти программу с преобладающими параллельными вычислениями, чтобы собрать данные и посмотреть на реальное использование данного регистра. Если даже в параллельной среде этот регистр задействован слабо, то можно избавиться от его кэширования, но если же он проявляет свою необходимость в данных приложениях, то стоит его оставить для большей универсальности OpenJDK порта. Остались регистры с кэшем хранилища констант (const\_pool) и метода (method), которые используются по 6-7 миллионов раз, если сопоставить ручную и автоматическую статистики. Эти показатели не очень высокие, однако пока не нашлось иных данных на замену, использование которых будет выше.

Автоматический сбор успешно справился с задачей проверки и уточнения ручного сбора статистики, однако, несмотря на вдвое большее количество рассмотренных данных, более удачных кандидатов на кэширование ещё не удалось выявить. Также не были рассмотрены регистры, необходимые для кэширования данных, помогающих облегчить отладочные сборки, профилирование OpenJDK, а также прочих побочных путей исполнения, в связи с тем, что в этих задачах скорость исполнения не является приоритетной ценностью, и ей можно пожертвовать при необходимости. 


\subsection{Выводы}

Были разработаны две методики сбора данных, с помощью совокупного использования которых удалось прийти к результатам. Незначительные отличия в данных с выбранных источников показывают их объективность. В результате удалось выяснить крайнюю важность таких регистров, как bcp, TOS, esp, threads, locals, fp и dispatch\_table. Также свою полезность продемонстрировало кэширование method и const\_pool. Если monitors и sender\_sp показали весьма сомнительные результаты, и потенциально от них можно избавиться, то от кэширования TOC в интерпретаторе нет никакой пользы, его можно кэшировать его только при входе в JIT компиляцию, если это технически возможно.

Данное исследование оказалось более трудоемким, чем изначально предполагалось, однако уже на данном этапе были сделаны выводы относительно использования, либо потенциального использования регистров в RISC-V порте, что так или иначе будет учтено при его дальнейшей разработке. Также интересным дополнительным результатом был вывод о том, что можно ускорить порт PowerPC, добавив в него отсутствующее кэширование fp регистра, что можно сделать, использовав ещё незадействованный регистр, либо же заменив на него sender\_sp.

Потенциальным продолжением данного исследования может быть задействование изменяющихся регистров в качестве кэшируемых, при сохранении их на стек при каждом Runtime вызове. Подобное исследование завязано не только на полной статистике по использованию данных, но и на полном анализе использования изменяемых регистров в коде, количество которых также весьма ограничено. 
