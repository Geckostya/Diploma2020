\section{Разработка и реализация фреймов}

Структуры фреймов в OpenJDK являются ключевыми элементами ABI всего интерпретатора и определяют такие вещи, как выбор и способ сохранения необходимой информации во время \glslink{интерпретация}{интерпретации} \gls{метод}[ов]; способ взаимодействия Java \gls{метод}[ов], как друг с другом, так и с JNI и Runtime \gls{метод}[ами], вызываемыми в процессе интерпретации; семантику взаимодействия со стеком вычислений, локальными значениями и аргументами. Правильное создание данных структур должно опираться как на нативную реализацию структуры \gls{фрейм}[ов], чтобы сохранить совместимость с нативными вызовами и инструментами отладки, так и на создание и использование этих структур в интерпретации, чтобы обеспечить максимально быструю работу приложения.


\subsection{Разработка структуры фреймов}

Первой задачей разработки структуры \gls{фрейм}[ов] было нахождение или составление описания нативных \gls{фрейм}[ов] для языка C. Данные, найденные в онлайн лекции Parallel \& Distributed Operating Systems Group~\cite{lecture_frames}, не являются официальным документом от разработчиков компилятора языка~C, поэтому их необходимо было проверить, для чего использовался \gls{метод} обратной инженерии. Были написаны различные программы на языке C, в которых были отражены ключевые сценарии вызовов \gls{метод}[ов], передачи аргументов и работы с локальными переменными. Далее, данный код был скомпилирован с помощью RISC-V GNU GCC~\cite{riscv:gnu} компилятора в ассемблерный код RISC-V, после чего в нём были выявлены места, отвечающие за создание и заполнение \gls{фрейм}[ов]. Семантика данного кода полностью соответствовала найденной структуре, и было принято решение использовать её в качестве основы для разработки Java \gls{фрейм}[ов]. 

Проектирование структуры Java \gls{фрейм}[ов] для RISC-V было основано на структуре \gls{фрейм}[ов] для архитектуры PowerPC, однако своё влияние на разработку оказали существенные различия в нативных \gls{фрейм}[ах] данных архитектур, а именно: нативный ABI RISC-V \gls{фрейм}[ов] содержит только адрес в памяти, указывающий на начало \textbf{предыдущего} \gls{фрейм}[а] (началом \gls{фрейм}[а] будем считать последний байт перед этим фреймом), и адрес возврата для \textbf{текущей} функции, в то время как у PowerPC хранится начало \textbf{текущего} \gls{фрейм}[а], адрес возврата \textbf{вызываемой} функции, имеется зарезервированное место под первые 8 аргументов и все эти значения лежат внизу \gls{фрейм}[а], а не наверху, как в RISC-V.
Данные отличия, а также наличие регистра fp\footnote{Образовано от frame pointer}, указывающего начало текущего \gls{фрейм}[а], повлекли изменения в реализации \gls{метод}[ов], которые помогают осуществить просмотр данных \gls{фрейм}[а] и навигацию между \gls{фрейм}[ами] во время исполнения внутренних Runtime вызовов.

    Одной из особенностей архитектуры RISC-V является обязательное выравнивание вниз на 16 байт значения в регистре sp\footnote{Образовано от stack pointer}, которое должно указывать на последний байт текущего \gls{фрейм}[а]. Во время исполнения кода необходимо соблюдать данное выравнивание, что означает выбор одного из трех решений:
\begin{enumerate}
    \item Применять выравнивание ко всем данным, выкладываемым на стек.
    \item Помнить невыровненное смещение относительно sp, при работе со стеком сдвигать и его, и значение в sp.
    \item Создавать \gls{фрейм} фиксированного размера и выкладывать все данные внутри него.
\end{enumerate}

Первый вариант нам не подходит из-за того, что размер данных на стеке увеличится примерно в 2 раза, что является неоправданной тратой памяти. Решено было выбрать третий, так как, хоть он и требует небольших накладных расходов памяти на поддержание места под значения, которые не всегда необходимо сохранять в памяти, однако, в отличие от второго, он не усложняет работу со значениями на стеке, что может существенно замедлить процесс интерпретации.
% TODO написать про то, что остальные поля заполнялись и менялись исходя из нуждн реализации
% TODO вставить ссылку на приложения со структурой фрейма

\subsection{Реализация входного фрейма}

Самой первой точкой входа в интерпретатор является генерация входного \gls{фрейм}[а], который, как и все остальные \gls{фрейм}[ы], написан с помощью нашего ассемблерного генератора. 

Для создания входного \gls{фрейм}[а] необходимо рассчитать и выделить под него место на стеке и заполнить все структуры, отображенные на \figref{входной_фрейм}, актуальными данными. Для заполнения нативного ABI необходимо сохранить в верхние два слова значения регистров ra\footnote{Образовано от return adress} и fp, которые указывают на адрес возврата функции и на начало предыдущего \gls{фрейм}[а] соответственно. "Сохраненные регистры" содержат в себе значения всех неизменяемых регистров, кроме fp и sp, это необходимо для соблюдения конвенции о вызовах~C~\cite{riscv:convention}, а именно, соблюдение правила о том, что неизменяемые регистры должны иметь одно и то же значение до и после вызова функции. Значение sp регистра будет сохранено в регистре fp, а значение fp мы сохранили в нативном ABI, поэтому их значения не нужно сохранять дополнительно. Локальные данные содержат несколько значений, доступ к которым может потребоваться во время интерпретации, а исходящие аргументы - это аргументы, пришедшие из C вызова, которые необходимо перекопировать на стек для совместимости разных вызовов.
 
\myfig{entry_frame.png}{Структура входного фрейма}{входной_фрейм}{0.5}
 
Во время заполнения данных структур возникали трудности с расставлением правильных смещений относительно fp регистра для точного определения начала структур. Также было необходимо правильно выбрать регистры для всех промежуточных расчетов, чтобы не получилось перекрытия данных. Помимо этого, на данном этапе появилась необходимость загрузки констант в регистры, так как архитектура RISC-V не предусматривает загрузку 64-битной константы в регистр одной инструкцией, и для этих целей нужно написать свой генератор, который по константе сгенерирует оптимальный набор инструкций, загружающих в регистр эту константу. Данный генератор уже написан в GCC, однако найти этот код в огромной системе не получилось, поэтому был написан собственный.

% \TODO{Нужно ли писать более точные технические подробности про генератор?}

% \TODO{Нужно ли указать, что генератор писался коллективно?}



\subsection{Реализация Java фрейма}
При вызове Java \gls{метод}[а] происходит создание Java \gls{фрейм}[а]. На предыдущем \gls{фрейм}[е] должны быть выложены аргументы, а регистр s7, который мы выбрали и назвали esp\footnote{Образовано от expression stack pointer}, и который указывает на первый свободный слот стека вычислений, в данном контексте указывает на место, куда необходимо выложить локалы. В зависимости от размера стека вычислений предыдущего \gls{фрейм}[а], занятого на нём места и количества аргументов и локалов текущего \gls{метод}[а], предыдущий \gls{фрейм} необходимо увеличить, чтобы вместились все данные, либо уменьшить, чтобы не занимать лишнего места на стеке, которое мы не будем использовать во время интерпретации текущего \gls{метод}[а], для этого нужно соответствующим образом сдвинуть регистр, указывающий на начало текущего \gls{фрейм}[а], запомнив конец предыдущего \gls{фрейм}[а] до смещения в специально отведенном месте на стеке, чтобы восстановить его первозданный вид после выхода из \gls{метод}[а].

Трудности в данной работе возникали, как и для входного \gls{фрейм}[а], в правильном расчете всех размеров и сдвигов. В отличие порта PowerPC, у нас нет необходимости перекопировать структуры нативного ABI при изменениях родительского \gls{фрейм}[а], а также у нас нет необходимости хранить на последнем \gls{фрейм}[е] место под 8 аргументов для Runtime вызовов. Данные отличия помогли изменить структуру расчетов размеров \gls{фрейм}[ов], сделав её проще и понятнее для восприятия, не жертвуя количеством инструкций, необходимых для этих расчетов.

\myfig{Ijava_frame.png}{Структура Java фрейма}{java_фрейм}{0.45}

Были предприняты попытки по значительному изменению структуры Java \gls{фрейм}[а], изображенного на \figref{java_фрейм}, однако они не увенчались успехом. Для упрощения обращения к аргументам и локалам \gls{метод}[а], которые находятся на предыдущем \gls{фрейм}[е], можно зарезервировать регистр, который будет указывать на начало этих данных. Однако можно заметить, что эти данные расположены прямо перед началом текущего \gls{фрейм}[а], таким образом, что регистр fp указывает на их конец, с учетом смещениия на 16 байт. Если полностью инвертировать порядок аргументов и локалов, то можно добиться того, чтобы fp указывал ровно на первый аргумент, и от него можно было бы получить доступ ко всем остальным, однако, в связи со спецификацией Java, аргументы выкладываются на стек с помощью обычных байткодов, выкладывающих любые значения на стек, что делает невозможным контроль данного процесса. Единственным возможным решением в данном случае является копирование аргументов в обратном порядке на новое место при вызове \gls{метод}[а], однако это слишком дорогая операция по количеству инструкций на обращение к стеку, и, в итоге, более правильным, в целях оптимизации, решением будет выделение дополнительного регистра для упрощения адресации.

Также были предприняты попытки изменить расположение мониторов\footnote{Специальные структуры, отвечающие за механизмы синхронизации многопоточных вычислений}, в связи с тем, что исходя из статических данных, полученных из Java компилятора, нельзя вычислить точное количество места, требуемого под расположение мониторов, что приводит к копированию всех данных под мониторами, при выкладывании их на стек и сопутствующим расширении \gls{фрейм}[а]. Исходя из данных рассуждений следует вывод, что необходимо располагать мониторы как можно ближе к концу \gls{фрейм}[а], чтобы как можно меньше данных пришлось копировать. При рассмотрении рисунка \ref{fig:java_фрейм}, следовательно, можно заметить, что передвигать мониторы на первую или вторую позицию будет менее рационально с позиции уменьшения количества копируемых данных. Исходящих аргументов и локалов на \gls{фрейм}[е] при выкладывании монитора ещё нет, в связи с тем, что мониторы выкладываются только на текущий фрейм, а значит остаются только позиции до или после стека вычислений, однако, исходя из того, что размер стека вычислений не учитывает количество локалов вызываемых \gls{метод}[ов], по причине невозможности данных подсчетов, при выкладывании мониторов после стека вычислений мы не только лишимся возможности быстрого изменения размера стека при вызове, чтобы занять свободное место стека вычислений, но и разорвем непрерывность аргументов и локалов на стеке, что увеличит количество операций, требуемых на работу с ними. Таким образом, в особенности учитывая тот факт, что мониторы выкладываются преимущественно при пустом стеке вычислений, их текущая позиция является оптимальной.



\subsection{Реализация нативного Java фрейма}
JNI \gls{метод}ы написаны на языках C или \cpp и для их вызова необходимо соблюдать конвенцию о вызовах C. Для решения этой задачи создается специальная структура нативного Java \gls{фрейм}[а], отличающаяся от своей ненативной реализации отсутствием стека вычислений и нативным форматом исходящих аргументов. Данный \gls{фрейм} является лишь прослойкой между Java и С языками, служащий лишь в качестве корректного форматирования аргументов, выкладывании монитора для синхронизированных вызовов и сохранением необходимых данных в структуре ijava\_state.


\myfig{native_frame.png}{Структура нативного Java фрейма}{нативный_java_фрейм}{0.6}


В OpenJDK копирование Java аргументов в C формат представлено двумя способами - быстрым и медленным. Данный выбор переключается с помощью выставления специального флага при запуске JVM, которая по умолчанию использует быструю реализацию. Медленное копирование аргументов читает сигнатуру \gls{метод}а непосредственно в ассемблерном коде, и по ней происходит копирование каждого типа данных из сигнатуры надлежащим образом. Данный \gls{метод} позволяет сгенерировать код один раз для всех вызовов \gls{метод}а, однако чтение и разбор сигнатуры из ассемблера накладывает дополнительные вычислительные затраты на данный код, а также требуют двух Runtime вызовов для взятия необходимых значений из \gls{метод}а. Быстрое копирование аргументов подразумевает генерацию уникального кода для каждой сигнатуры, который будет максимально быстро копировать аргументы, зная про формат сигнатуры на момент генерации. В рамках данной работы было реализовано оба этих \gls{метод}а.

В процессе генерации нативного Java \gls{фрейм}[а] делается значительно больше проверок и обработок исключительных ситуаций, чем при генерации ненативного \gls{фрейм}[а]. Помимо этого, появляется необходимость обработки результата JNI \gls{метод}а, чтобы он соответствовал значениям Java типов, специфицированных в JVMS. Так, например, значения булевого\footnote{Тип данных, имеющий только два значения - ложь и истина} типа в Java должны содержать только $0$ или $1$, что является ложью или истиной соответственно, в то время как в спецификации C указано, что $0$ соответствует ложному значению, а любое другое число истинному. В связи с подобными ограничениями были придуманы и реализованы минимальные по сложности инструкции переводов значений C типов в значения, удовлетворяющие Java спецификации и внутренней работе порта.

% \TODO{Ссылки на код в приложении? Объяснение примера с булевым значением?}

\subsection{Выводы}

В глобальную структуру фреймов не удалось привнести ничего кардинально нового, однако каждое принятое решение по структуре было обдумано и обосновано. Особенности платформы RISC-V были корректно учтены при проектировании фреймов, что отразилось в фиксированном размере каждого фрейма, нативном ABI, копировании нативных аргументов и прочем. Реализация генерации данных структур, их заполнении и поддержки была сделана с учетом необходимости высокой скорости работы приложения, что выражается в экономии количества вызванных инструкций.
