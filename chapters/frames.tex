\section{Разработка и реализация фреймов}

Структуры фреймов в OpenJDK являются ключевыми элементами ABI всего интерпретатора и определяют такие вещи, как выбор и способ сохранения необходимой информации во время интерпретации методов; способ взаимодействия Java методов, как друг с другом, так и с JNI и Runtime методами, вызываемыми в процессе интерпретации; семантику взаимодействия со стеком вычислений, локальными значениями и аргументами. Правильное создание данных структур должно опираться как на нативную реализацию структуры фреймов, чтобы сохранить совместимость с нативными вызовами и инструментами отладки, так и на создание и использование этих структур в интерпретации, чтобы обеспечить максимально быструю работу приложения.


\subsection{Разработка структуры фреймов}

Первой задачей разработки структуры фреймов было нахождение или составление описания нативных фреймов для языка C. Данные, найденные в онлайн лекции Parallel \& Distributed Operating Systems Group~\cite{lecture_frames}, не являются официальным документом от разработчиков компилятора языка~C, поэтому их необходимо было проверить, для чего использовался метод обратной инженерии. Были написаны различные программы на языке C, в которых были отражены ключевые сценарии вызовов методов, передачи аргументов и работы с локальными переменными. Далее, данный код был скомпилирован с помощью RISC-V GNU GCC~\cite{riscv:gnu} компилятора в ассемблерный код RISC-V, после чего в нём были выявлены места, отвечающие за создание и заполнение фреймов. Семантика данного кода полностью соответствовала найденной структуре, и было принято решение использовать её в качестве основы для разработки Java фреймов. 

Проектирование структуры Java фреймов для RISC-V было основано на структуре фреймов для архитектуры PowerPC, однако своё влияние на разработку оказали существенные различия в нативных фреймах данных архитектур, а именно: нативный ABI RISC-V фреймов содержит только адрес в памяти, указывающий на начало \textbf{предыдущего} фрейма (началом фрейма будем считать последний байт перед этим фреймом), и адрес возврата для \textbf{текущей} функции, в то время как у PowerPC хранится начало \textbf{текущего} фрейма, адрес возврата \textbf{вызываемой} функции, имеется зарезервированное место под первые 8 аргументов и все эти значения лежат внизу фрейма, а не наверху, как в RISC-V.
Данные отличия, а также наличие регистра fp\footnote{Образовано от frame pointer}, указывающего начало текущего фрейма, повлекли изменения в реализации методов, которые помогают осуществить просмотр данных фрейма и навигацию между фреймами во время исполнения внутренних Runtime вызовов.

    Одной из особенностей архитектуры RISC-V является обязательное выравнивание вниз на 16 байт значения указателя стека, расположенного в регистре sp\footnote{Образовано от stack pointer}, которое должно указывать на последний байт текущего фрейма. Во время исполнения кода необходимо соблюдать данное выравнивание, что означает выбор одного из трех решений:
\begin{enumerate}
    \item Применять выравнивание ко всем данным, выкладываемым на стек.
    \item Помнить невыровненное смещение относительно sp, при работе со стеком сдвигать и его, и значение в sp.
    \item Создавать фрейм фиксированного размера и выкладывать все данные внутри него.
\end{enumerate}

Первый вариант не подходит из-за того, что размер данных на стеке увеличится примерно в 2 раза, что является неоправданной тратой памяти. Решено было выбрать третий, так как, хоть он и требует небольших накладных расходов памяти на поддержание места под значения, которые не всегда необходимо сохранять в памяти, однако, в отличие от второго, он не усложняет работу со значениями на стеке, что может существенно замедлить процесс интерпретации.

\subsection{Реализация входного фрейма}

Самой первой точкой входа в интерпретатор является генерация входного фрейма, который, как и все остальные фреймы, написан с помощью генератора RISC-V ассемблера. Генерация входного фрейма нужна для согласования C ABI с внутренним устройством и ABI Java, а также для сохранения ряда вспомогательных значений, требуемых во время интерпретации.

Для создания входного фрейма необходимо рассчитать и выделить под него место на стеке и заполнить все структуры, отображенные на \figref{входной_фрейм}, актуальными данными. Для заполнения нативного ABI необходимо сохранить в верхние два слова значения регистров ra\footnote{Образовано от return adress} и fp, которые указывают на адрес возврата функции и на начало предыдущего фрейма соответственно. "Сохраненные регистры" содержат в себе значения всех неизменяемых\footnote{Авторский перевод термина non-volatile. Также в литературе встречается синоним данного термина callee save} регистров, кроме fp и sp, это необходимо для соблюдения конвенции о вызовах~C~\cite{riscv:convention}, а именно, соблюдение правила о том, что неизменяемые регистры должны иметь одно и то же значение до и после вызова функции. Значение sp регистра будет сохранено в регистре fp, а значение fp в нативном ABI, поэтому их не нужно сохранять дополнительно. Локальные данные содержат несколько значений, доступ к которым может потребоваться во время интерпретации, а исходящие аргументы - это аргументы, пришедшие из C вызова, которые необходимо перекопировать на стек для совместимости разных вызовов.
 
\myfig{entry_frame.png}{Структура входного фрейма}{входной_фрейм}{0.5}
 
Во время заполнения данных структур возникали трудности с расставлением правильных смещений относительно fp регистра для точного определения начала структур, которые были решены созданием вспомогательных методов, рассчитывающих данные сдвиги, а результаты были тщательно проверены с помощью отладчика. Также было необходимо правильно выбрать регистры для всех промежуточных расчетов, чтобы не получилось перекрытия данных. Помимо этого, на данном этапе появилась необходимость загрузки констант в регистры, так как архитектура RISC-V не предусматривает загрузку 64-битной константы в регистр одной инструкцией, и для этих целей нужно написать свой генератор, который по константе сгенерирует оптимальный набор инструкций, загружающих в регистр эту константу. Данный генератор уже написан в GCC, однако найти этот код в огромной системе не получилось, поэтому был написан собственный.

Генератор загрузок констант разрабатывался итеративно, сначала была написана простая версия, которая прибавляла верхние 11 бит к нулевому значению, а затем сдвигала биты регистра на 11 влево и повторяла процесс, пока вся константа не будет загружена. Данная тривиальная реализация помогла отлаживать более трудные реализации, так как при возникновении ошибок можно было её применить, и, если ошибка исчезала, то значит проблема крылась именно в неверной генерации. Однако, помимо неоптимальности генерации, данный подход также порождал большое количество инструкций, которые усложняли отладку и чтение генерирующегося кода, поэтому постепенно в данную конструкцию вносились разные улучшения, уменьшающие количество сгенерированных инструкций. Последним этапом было написание рекурсивного алгоритма, который пытался загрузить как можно большее количество байт с помощью побитовых сдвигов, добавлений знаковых 12-битных чисел и загрузки двадцати бит в середину числа, и, если у него не получалось загрузить число целиком, результат сдвигался и рекурсивно загружалась следующая часть. 



\subsection{Реализация Java фрейма}
При вызове Java метода происходит создание Java фрейма. На предыдущем фрейме должны быть размещены аргументы, а регистр s7, который был выбран и назван esp\footnote{Образовано от expression stack pointer}, и который указывает на первый свободный слот стека вычислений, в данном контексте указывает на место, куда необходимо выложить локалы. В зависимости от размера стека вычислений предыдущего фрейма, занятого на нём места и количества аргументов и локалов текущего метода, предыдущий фрейм необходимо увеличить, чтобы вместились все данные, либо уменьшить, чтобы не занимать лишнего места на стеке, которое не будет использоваться во время интерпретации текущего метода, для этого нужно соответствующим образом сдвинуть регистр, указывающий на начало текущего фрейма, запомнив конец предыдущего фрейма до смещения в специально отведенном месте на стеке, чтобы восстановить его первозданный вид после выхода из метода.

Как и во входном фрейме, необходимо корректно рассчитать все размеры и сдвиги, поэтому применялись те же средства отладки. В отличие порта PowerPC, в RISC-V нет необходимости перекопировать структуры нативного ABI при изменениях родительского фрейма, а также нет необходимости хранить на последнем фрейме место под 8 аргументов для Runtime вызовов. Данные отличия помогли изменить структуру расчетов размеров фреймов, сделав её проще и понятнее для восприятия, не жертвуя количеством инструкций, необходимых для этих расчетов.

\myfig{Ijava_frame.png}{Структура Java фрейма}{java_фрейм}{0.45}

Структура Java фрейма представлена на \figref{java_фрейм}. Поле ijava_state --- это структура, в которую записываются необходимые данные для интерпретации текущего метода, а также дополнительные поля, в которые может быть сохранена информация между вызовами. Часть данной информации также используется при Runtime вызовах, поэтому перед изменениями в данной структуре необходимо проводить тщательный анализ.

Для упрощения обращения к аргументам и локалам метода, которые находятся на предыдущем фрейме, можно зарезервировать регистр, который будет указывать на начало этих данных. Однако, есть иной подход к адресации, можно заметить, что эти данные расположены прямо перед началом текущего фрейма, таким образом, что регистр fp указывает на их конец, с учетом смещения на 16 байт. Если полностью инвертировать порядок аргументов и локалов, то можно добиться того, чтобы fp указывал ровно на первый аргумент, и от него можно было бы получить доступ ко всем остальным, однако, в связи со спецификацией Java, аргументы выкладываются на стек с помощью обычных байткодов, выкладывающих любые значения на стек, что делает невозможным контроль данного процесса. Единственным возможным решением в данном случае является копирование аргументов в обратном порядке на новое место при вызове метода, однако это слишком дорогая операция по количеству инструкций на обращение к стеку, и, в итоге, более правильным, в целях оптимизации, решением будет выделение дополнительного регистра для упрощения адресации.

Также была рассмотрена идея изменения расположения мониторов\footnote{Специальные структуры, отвечающие за механизмы синхронизации многопоточных вычислений} на стеке. Исходя из статических данных, полученных из Java компилятора, нельзя вычислить точное количество места, требуемое под расположение мониторов, и поэтому, при добавлении монитора, стек расширяется, а все данные под монитором должны быть скопированы на несколько байт ниже. Исходя из данных системных ограничений следует вывод, что необходимо располагать мониторы как можно ближе к концу фрейма, чтобы как можно меньше данных пришлось копировать. При рассмотрении рисунка \ref{fig:java_фрейм}, следовательно, можно заметить, что передвигать мониторы на первую или вторую позицию будет менее рационально с позиции уменьшения количества копируемых данных. Исходящих аргументов и локалов на фрейме при выкладывании монитора ещё нет, в связи с тем, что мониторы выкладываются только на текущий фрейм, а значит остаются только позиции до или после стека вычислений, однако, исходя из того, что размер стека вычислений не учитывает количество локалов вызываемых методов, по причине невозможности данных подсчетов, при выкладывании мониторов после стека вычислений не только утратится возможность быстрого изменения размера стека при вызове, чтобы занять свободное место стека вычислений, но и разорвется непрерывность аргументов и локалов на стеке, что увеличит количество операций, требуемых на работу с ними. Таким образом, в особенности учитывая тот факт, что мониторы выкладываются преимущественно при пустом стеке вычислений, их текущая позиция является оптимальной.



\subsection{Реализация нативного Java фрейма}
JNI методы написаны на языках C или \cpp и для их вызова необходимо соблюдать конвенцию о вызовах C. Для решения этой задачи создается специальная структура нативного Java фрейма, отличающаяся от своей ненативной реализации отсутствием стека вычислений и нативным форматом исходящих аргументов. Данный фрейм является лишь прослойкой между Java и С языками, служащий лишь в качестве корректного форматирования аргументов, выкладывании монитора для синхронизированных вызовов и сохранением необходимых данных в структуре ijava\_state.


\myfig{native_frame.png}{Структура нативного Java фрейма}{нативный_java_фрейм}{0.6}


В OpenJDK копирование Java аргументов в C формат представлено двумя способами - быстрым и медленным. Данный выбор переключается с помощью выставления специального флага при запуске JVM, которая по умолчанию использует быструю реализацию, а также быстрый способ не применяется для слишком длинных сигнатур. Медленное копирование аргументов читает сигнатуру метода непосредственно в ассемблерном коде, и по ней происходит копирование каждого типа данных из сигнатуры надлежащим образом. Данный метод позволяет сгенерировать код один раз для всех вызовов метода, однако чтение и разбор сигнатуры из ассемблера накладывает дополнительные вычислительные затраты на данный код, а также требуют двух Runtime вызовов для взятия необходимых значений из метода. Быстрое копирование аргументов подразумевает генерацию уникального кода для каждой сигнатуры, который будет максимально быстро копировать аргументы, зная про формат сигнатуры на момент генерации. В рамках данной работы было реализовано оба этих метода.

В процессе генерации нативного Java фрейма делается значительно больше проверок и обработок исключительных ситуаций, чем при генерации ненативного фрейма. Помимо этого, появляется необходимость обработки результата JNI метода, чтобы он соответствовал значениям Java типов, специфицированных в JVMS. Так, например, значения булевого\footnote{Тип данных, имеющий только два значения - ложь и истина} типа в Java должны содержать только $0$ или $1$, что является ложью или истиной соответственно, в то время как в спецификации C указано, что $0$ соответствует ложному значению, а любое другое число истинному. В связи с подобными ограничениями были придуманы и реализованы минимальные по сложности инструкции переводов значений C типов в значения, удовлетворяющие Java спецификации и внутренней работе порта.

% \TODO{Ссылки на код в приложении? Объяснение примера с булевым значением?}

\subsection{Выводы}

Каждое принятое решение по изменению структуры фреймов было обдумано и обосновано. Особенности платформы RISC-V были корректно учтены при проектировании фреймов, что отразилось в фиксированном размере каждого фрейма, нативном ABI, копировании нативных аргументов и прочем. Реализация генерации данных структур, их заполнении и поддержки была сделана с учетом необходимости высокой скорости работы приложения, что выражается в экономии количества вызванных инструкций.
