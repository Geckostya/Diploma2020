\section{Разработка и реализация фреймов}

Структуры фреймов в OpenJDK являются ключевыми элементами ABI всего интерпретатора и определяют такие вещи, как выбор и способ сохранения необходимой информации во время интерпретации методов; способ взаимодействия Java методов, как друг с другом, так и с JNI и Runtime методами, вызываемыми в процессе интерпретации; семантику взаимодействия со стеком вычислений, локальными значениями и аргументами. Правильное создание данных структур должно опираться как на нативную реализацию структуры фреймов, чтобы сохранить совместимость с нативными вызовами и инструментами отладки, так и на создание и использование этих структур в интерпретации, чтобы обеспечить максимально быструю работу приложения.


\subsection{Разработка структуры фреймов}

Первой задачей разработки структуры фреймов было нахождение или составление описания нативных фреймов для языка C. Данные, найденные в онлайн лекции Parallel \& Distributed Operating Systems Group~\cite{lecture_frames}, не являются официальным документом от разработчиков компилятора языка~C, поэтому их необходимо было проверить, для чего использовался метод обратной инженерии. Были написаны различные программы на языке C, в которых были отражены ключевые сценарии вызовов методов, передачи аргументов и работы с локальными переменными. Далее, данный код был скомпилирован с помощью RISC-V GNU GCC~\cite{riscv:gnu} компилятора в ассемблерный код RISC-V, после чего в нём были выявлены места, отвечающие за создание и заполнение фреймов. Семантика данного кода полностью соответствовала найденной структуре, и было принято решение использовать её в качестве основы для разработки Java фреймов. 

Проектирование структуры Java фреймов для RISC-V было основано на структуре фреймов для архитектуры PowerPC, однако своё влияние на разработку оказали существенные различия в нативных фреймах данных архитектур, а именно: нативный ABI RISC-V фреймов содержит только адрес в памяти, указывающий на начало \textbf{предыдущего} фрейма (началом фрейма будем считать последний байт перед этим фреймом), и адрес возврата для \textbf{текущей} функции, в то время как у PowerPC хранится начало \textbf{текущего} фрейма, адрес возврата \textbf{вызываемой} функции, имеется зарезервированное место под первые 8 аргументов и все эти значения лежат внизу фрейма, а не наверху, как в RISC-V.
Данные отличия, а также наличие регистра fp\footnote{Образовано от frame pointer}, указывающего начало текущего фрейма, повлекли изменения в реализации методов, которые помогают осуществить просмотр данных фрейма и навигацию между фреймами во время исполнения внутренних Runtime вызовов.

    Одной из особенностей архитектуры RISC-V является обязательное выравнивание вниз на 16 байт значения в регистре sp\footnote{Образовано от stack pointer}, которое должно указывать на последний байт текущего фрейма. Во время исполнения кода необходимо соблюдать данное выравнивание, что означает выбор одного из трех решений:
\begin{enumerate}
    \item Применять выравнивание ко всем данным, выкладываемым на стек.
    \item Помнить невыровненное смещение относительно sp, при работе со стеком сдвигать и его, и значение в sp.
    \item Создавать фрейм фиксированного размера и выкладывать все данные внутри него.
\end{enumerate}

Первый вариант нам не подходит из-за того, что размер данных на стеке увеличится примерно в 2 раза, что является неоправданной тратой памяти. Решено было выбрать третий, так как, хоть он и требует небольших накладных расходов памяти на поддержание места под значения, которые не всегда необходимо сохранять в памяти, однако, в отличие от второго, он не усложняет работу со значениями на стеке, что может существенно замедлить процесс интерпретации.
% TODO написать про то, что остальные поля заполнялись и менялись исходя из нуждн реализации
% TODO вставить ссылку на приложения со структурой фрейма

\subsection{Реализация входного фрейма}

Самой первой точкой входа в интерпретатор является генерация входного фрейма, который, как и все остальные фреймы, написан с помощью нашего ассемблерного генератора. 

Для создания входного фрейма необходимо рассчитать и выделить под него место на стеке и заполнить все структуры, отображенные на \figref{входной_фрейм}, актуальными данными. Для заполнения нативного ABI необходимо сохранить в верхние два слова значения регистров ra\footnote{Образовано от return adress} и fp, которые указывают на адрес возврата функции и на начало предыдущего фрейма соответственно. "Сохраненные регистры" содержат в себе значения всех неизменяемых регистров, кроме fp и sp, это необходимо для соблюдения конвенции о вызовах~C~\cite{riscv:convention}, а именно, соблюдение правила о том, что неизменяемые регистры должны иметь одно и то же значение до и после вызова функции. Значение sp регистра будет сохранено в регистре fp, а значение fp мы сохранили в нативном ABI, поэтому их значения не нужно сохранять дополнительно. Локальные данные содержат несколько значений, доступ к которым может потребоваться во время интерпретации, а исходящие аргументы - это аргументы, пришедшие из C вызова, которые необходимо перекопировать на стек для совместимости разных вызовов.
 
\myfig{entry_frame.png}{Структура входного фрейма}{входной_фрейм}{0.5}
 
Во время заполнения данных структур возникали трудности с расставлением правильных смещений относительно fp регистра для точного определения начала структур. Также было необходимо правильно выбрать регистры для всех промежуточных расчетов, чтобы не получилось перекрытия данных. Помимо этого, на данном этапе появилась необходимость загрузки констант в регистры, так как архитектура RISC-V не предусматривает загрузку 64-битной константы в регистр одной инструкцией, и для этих целей нужно написать свой генератор, который по константе сгенерирует оптимальный набор инструкций, загружающих в регистр эту константу. Данный генератор уже написан в GCC, однако найти этот код в огромной системе не получилось, поэтому был написан собственный.

% \TODO{Нужно ли писать более точные технические подробности про генератор?}

% \TODO{Нужно ли указать, что генератор писался коллективно?}



\subsection{Реализация Java фрейма}
При вызове Java метода происходит создание Java фрейма. На предыдущем фрейме должны быть выложены аргументы, а регистр s7, который мы выбрали и назвали esp\footnote{Образовано от expression stack pointer}, и который указывает на первый свободный слот стека вычислений, в данном контексте указывает на место, куда необходимо выложить локалы. В зависимости от размера стека вычислений предыдущего фрейма, занятого на нём места и количества аргументов и локалов текущего метода, предыдущий фрейм необходимо увеличить, чтобы вместились все данные, либо уменьшить, чтобы не занимать лишнего места на стеке, которое мы не будем использовать во время интерпретации текущего метода, для этого нужно соответствующим образом сдвинуть регистр, указывающий на начало текущего фрейма, запомнив конец предыдущего фрейма до смещения в специально отведенном месте на стеке, чтобы восстановить его первозданный вид после выхода из метода.

Трудности в данной работе возникали, как и для входного фрейма, в правильном расчете всех размеров и сдвигов. В отличие порта PowerPC, у нас нет необходимости перекопировать структуры нативного ABI при изменениях родительского фрейма, а также у нас нет необходимости хранить на последнем фрейме место под 8 аргументов для Runtime вызовов. Данные отличия помогли изменить структуру расчетов размеров фреймов, сделав её проще и понятнее для восприятия, не жертвуя количеством инструкций, необходимых для этих расчетов.

\myfig{Ijava_frame.png}{Структура Java фрейма}{java_фрейм}{0.45}

Были предприняты попытки по значительному изменению структуры Java фрейма, изображенного на \figref{java_фрейм}, однако они не увенчались успехом. Для упрощения обращения к аргументам и локалам метода, которые находятся на предыдущем фрейме, можно зарезервировать регистр, который будет указывать на начало этих данных. Однако можно заметить, что эти данные расположены прямо перед началом текущего фрейма, таким образом, что регистр fp указывает на их конец, с учетом смещениия на 16 байт. Если полностью инвертировать порядок аргументов и локалов, то можно добиться того, чтобы fp указывал ровно на первый аргумент, и от него можно было бы получить доступ ко всем остальным, однако, в связи со спецификацией Java, аргументы выкладываются на стек с помощью обычных байткодов, выкладывающих любые значения на стек, что делает невозможным контроль данного процесса. Единственным возможным решением в данном случае является копирование аргументов в обратном порядке на новое место при вызове метода, однако это слишком дорогая операция по количеству инструкций на обращение к стеку, и, в итоге, более правильным, в целях оптимизации, решением будет выделение дополнительного регистра для упрощения адресации.

Также были предприняты попытки изменить расположение мониторов\footnote{Специальные структуры, отвечающие за механизмы синхронизации многопоточных вычислений}, в связи с тем, что исходя из статических данных, полученных из Java компилятора, нельзя вычислить точное количество места, требуемого под расположение мониторов, что приводит к копированию всех данных под мониторами, при выкладывании их на стек и сопутствующим расширении фрейма. Исходя из данных рассуждений следует вывод, что необходимо располагать мониторы как можно ближе к концу фрейма, чтобы как можно меньше данных пришлось копировать. При рассмотрении рисунка \ref{fig:java_фрейм}, следовательно, можно заметить, что передвигать мониторы на первую или вторую позицию будет менее рационально с позиции уменьшения количества копируемых данных. Исходящих аргументов и локалов на фрейме при выкладывании монитора ещё нет, в связи с тем, что мониторы выкладываются только на текущий фрейм, а значит остаются только позиции до или после стека вычислений, однако, исходя из того, что размер стека вычислений не учитывает количество локалов вызываемых методов, по причине невозможности данных подсчетов, при выкладывании мониторов после стека вычислений мы не только лишимся возможности быстрого изменения размера стека при вызове, чтобы занять свободное место стека вычислений, но и разорвем непрерывность аргументов и локалов на стеке, что увеличит количество операций, требуемых на работу с ними. Таким образом, в особенности учитывая тот факт, что мониторы выкладываются преимущественно при пустом стеке вычислений, их текущая позиция является оптимальной.



\subsection{Реализация нативного Java фрейма}
JNI методы написаны на языках C или \cpp и для их вызова необходимо соблюдать конвенцию о вызовах C. Для решения этой задачи создается специальная структура нативного Java фрейма, отличающаяся от своей ненативной реализации отсутствием стека вычислений и нативным форматом исходящих аргументов. Данный фрейм является лишь прослойкой между Java и С языками, служащий лишь в качестве корректного форматирования аргументов, выкладывании монитора для синхронизированных вызовов и сохранением необходимых данных в структуре ijava\_state.


\myfig{native_frame.png}{Структура нативного Java фрейма}{нативный_java_фрейм}{0.6}


В OpenJDK копирование Java аргументов в C формат представлено двумя способами - быстрым и медленным. Данный выбор переключается с помощью выставления специального флага при запуске JVM, которая по умолчанию использует быструю реализацию. Медленное копирование аргументов читает сигнатуру метода непосредственно в ассемблерном коде, и по ней происходит копирование каждого типа данных из сигнатуры надлежащим образом. Данный метод позволяет сгенерировать код один раз для всех вызовов метода, однако чтение и разбор сигнатуры из ассемблера накладывает дополнительные вычислительные затраты на данный код, а также требуют двух Runtime вызовов для взятия необходимых значений из метода. Быстрое копирование аргументов подразумевает генерацию уникального кода для каждой сигнатуры, который будет максимально быстро копировать аргументы, зная про формат сигнатуры на момент генерации. В рамках данной работы было реализовано оба этих метода.

В процессе генерации нативного Java фрейма делается значительно больше проверок и обработок исключительных ситуаций, чем при генерации ненативного фрейма. Помимо этого, появляется необходимость обработки результата JNI метода, чтобы он соответствовал значениям Java типов, специфицированных в JVMS. Так, например, значения булевого\footnote{Тип данных, имеющий только два значения - ложь и истина} типа в Java должны содержать только $0$ или $1$, что является ложью или истиной соответственно, в то время как в спецификации C указано, что $0$ соответствует ложному значению, а любое другое число истинному. В связи с подобными ограничениями были придуманы и реализованы минимальные по сложности инструкции переводов значений C типов в значения, удовлетворяющие Java спецификации и внутренней работе порта.

% \TODO{Ссылки на код в приложении? Объяснение примера с булевым значением?}

\subsection{Выводы}

В глобальную структуру фреймов не удалось привнести ничего кардинально нового, однако каждое принятое решение по структуре было обдумано и обосновано. Особенности платформы RISC-V были корректно учтены при проектировании фреймов, что отразилось в фиксированном размере каждого фрейма, нативном ABI, копировании нативных аргументов и прочем. Реализация генерации данных структур, их заполнении и поддержки была сделана с учетом необходимости высокой скорости работы приложения, что выражается в экономии количества вызванных инструкций.
