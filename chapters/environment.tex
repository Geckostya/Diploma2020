\newpage
\safeoldsection[Подготовительные работы для портирования OpenJDK]{Подготовительные работы для\newline портирования OpenJDK}

Для разработки порта под другую платформу необходимо сделать некоторые предварительные шаги для инициализации всей работы. Этот этап разработки, в отличие от всех последующих, выполнялся совместно, в команде из 4 человек. 
Далее, на протяжении данной главы, о задачах, выполненных индивидуально, будет оговариваться отдельно. В остальных же задачах либо было принято частичное участие, либо они выполнялись полностью командно.

\subsection[Настройка обеспечения для разработки на базе RISC-V]{Настройка обеспечения для разработки\newline на базе RISC-V}

Процессоры, произведенные на базе архитектуры RISC-V ещё не поступили в массовое производство, а тестовые образцы поставляются в очень ограниченном количестве и приобрести их проблематично \cite{sifive} из-за высокого спроса на модели, способные запустить операционную систему. В связи с этой проблемой единственным доступным способом является разработка на эмуляторе RISC-V, который также способен запустить операционную систему.

Был найден QEMU эмулятор RISC-V \cite{riscv:qemu}, который ещё находится в разработке, но уже способен запускать linux и работать безошибочно для большинства задач, а также выбран RISC-V GNU toolchain \cite{riscv:gnu}, содержащий необходимые инструменты разработки для кросс-компиляции\footnote{Компиляции кода на платформу, отличную от той, на которой запущен кросс-компилятор} и отладки \cpp кода на RISC-V. Были написаны docker\footnote{Программа для удобной контейнеризации и развертки программных сред} образы для более удобной командной разработки и переносимости настроенного окружения. Также были написаны скрипты для упрощенного запуска данных образов с монтированием директорий и настройкой всех необходимых параметров.

Для отладки был использован GDB из RISC-V GNU toolchain, который работал с кодом, выполняющимся на QEMU, посредством клиент-серверного взаимодействия, так как возможностей GDB, реализованного на RISC-V, не хватало для тщательной отладки. Однако, подобное взаимодействие усложнило настройку GDB, поэтому, в качестве индивидуальной работы, были написаны специальные скрипты для запуска сервера и клиента с различными флагами, а также подключением отладочных символов проекта.


    
\subsection{Настройка OpenJDK}

Для проверки корректности настроенного окружения было решено запустить zero порт OpenJDK, который написан на \cpp и является почти полностью кроссплатформенным, однако для его запуска было необходимо избавиться от ошибок компиляции, возникающих в платформозависимых вставках в общей для всех портов части кода. В итоге, zero порт успешно запустился на эмуляторе RISC-V, и инициализация Java машины на нём занимала около двух минут, что демонстрирует низкую производительность QEMU и zero порта.

% \TODO{Стоит ли писать про настройку индексации в Clion?}
% Также мы смогли настроить clion для работы с OpenJDK и её корректной индексации, что, в целом, не предполагается разработчиками Java

Ради ускорения разработки был выбран стандартный метод портирования, заключающийся в копировании исходного кода некого порта и его постепенном переписывании. Для данной цели решено было выбрать порт PowerPC, так как его код показался чище, а архитектура ближе к RISC-V, чем другие. Тем не менее, данный выбор не является критичным или ключевым, и был сделан, по большей части, из соображений удобства, а при решении некоторых задач рассматривались реализации других портов OpenJDK.

Прежде чем приступить к платформозависимой реализации интерпретатора, были устранены ошибки компиляции, вызванные копированием другого порта, а также настроены некоторые платформозависимые части общего для всех портов кода.


\subsection{Реализация базовой функциональности порта}

Процесс интерпретации происходит с помощью ассемблерного кода, генерирующегося при инициализации JVM. В общей части OpenJDK реализован фреймворк, с помощью которого можно написать свой генератор ассемблерного кода. Для данной работы были воссозданы все правила генерации кодов инструкций, описанные в спецификации RISC-V, и таким образом генератор был реализован. Индивидуальный вклад был сделан посредством реализации псевдо-инструкций\footnote{Инструкции, реализованные через другие инструкции}, а также тщательной проверкой соответствия значений и семантик между спецификацией RISC-V и реализованным генератором.

В OpenJDK реализован код, который печатает файл с ошибками и состоянием системы при исключительных ситуациях и экстренном выходе из программы. Основная часть данной реализации зависит одновременно от операционной системы и архитектуры процессора. Было решено написать эту часть и для порта RISC-V, что помогло бы ускорить нахождение ошибок, возникающих при написании системы, и эта задача выполнялась индивидуально. Однако, из-за ошибки в эмуляторе, значение всех регистров портилось при обработке ошибок на процессоре. Данное поведение помешало разработке, и процесс был остановлен до исправления этой ошибки. Позднее, в версии 4.2.0, разработчики QEMU исправили данную ошибку, однако данная часть так и осталась нереализованной в связи с меньшей актуальностью, так как с течением времени количество ошибок уменьшалось, а их локальность повышалась.


\subsection{Выводы}

В качестве системы исполнения кода был выбран эмулятор QEMU, а для компиляции и отладки кода был выбран RISC-V GNU toolchain, и всё это было положено в docker образы для удобной дальнейшей работы. Окружение было успешно настроено, что было проверено запуском zero порта. Для процесса портирования был выбран PowerPC порт в качестве основы для реализации, также был написан генератор ассемблерного кода RISC-V, и предпринята попытка реализации кода, отвечающего за печать ошибок виртуальной машины, однако из-за технических проблем было принято решение отложить данную часть реализации.


