% У введения нет номера главы
\section*{Введение}
\renewcommand{\thefigure}{\arabic{figure}}
\subsection*{Актуальность и релевантные работы}

RISC-V --- это open-source архитектура процессора, которая с 2010 года разрабатывается для широкого круга применений. Данная разработка поддерживается многими крупными компаниями \cite{riscv:members}, в том числе такими как Alibaba, Google, Huawei, NVIDIA, Western Digital.

На текущий момент, платформа поддерживает исполнение множества программ и языков \cite{riscv:soft}, однако исполнение языка Java на RISC-V возможно только на двух исследовательских Java машинах \cite{jikes, maxine}, не подходящих для продуктовых решений из-за низкой производительности, которая очень важна пользователям и разработчикам.

OpenJDK --- это open-source проект, в котором разрабатывают эталонную \cite{openjdk_reference, openjdk:FAQ} продуктовую реализацию Java Development Kit (JDK), которая содержит Java Virtual Machine (JVM), библиотеку классов и прочие инструменты разработки, такие как компилятор javac. Реализация JVM платформозависима, и её порты реализованы для многих современных архитектур \cite{openjdk:platforms}, но всё ещё нет порта для RISC-V.

\myfig{jvm.png}{Схематичное устройство JVM}{jvm}{0.6}

Упрощенное схематичное устройство JVM представлено на \figref{jvm}, сначала Java код компилируется в Bytecode инструкции (байткоды), которые попадают в JVM и там происходит их ассемблерная интерпретация в шаблонном интерпретаторе. Принцип данного интерпретатора заключается в сопоставлении каждому байткоду определенного набор ассемблерных инструкций, моделирующих его семантику. Затем, когда статистика по исполнению будет собрана, активируется Just In Time (JIT) компилятор, оптимизирующий исполняемый код, однако периодически происходит деоптимизация кода, и исполнение снова возвращается в интерпретатор. Как видно, шаблонный интерпретатор --- ключевая и неотъемлемая часть JVM, наличие которой позволяет исполнять любой Java код.

При имплементации шаблонного интерпретатора необходимо продумать и реализовать его двоичный интерфейс приложения\footnote{Авторский перевод термина Application Binary Interface} (ABI), ключевую роль в котором занимают фреймы --- структуры данных, создаваемые на стеке при вызове функций. В Java фреймы содержат аргументы, локалы и прочие данные для интерпретации и выполнения ABI. Есть три ключевых перехода между функциями - из C функции в Java метод через входной фрейм, из Java в Java через Java фрейм и из Java в C через нативный Java фрейм.



\subsection*{Цель и задачи}

Данная работа ставит своей целью разработку и реализацию ABI шаблонного интерпретатора для порта OpenJDK на архитектуру процессора RISC-V. Для этого ставятся следующие задачи:

\begin{enumerate}
    \item Провести подготовительные работы для портирования OpenJDK, включающие в себя настройку рабочего окружения и реализацию базовых компонент порта OpenJDK.
    \item Разработать структуры фреймов и реализовать их для трех типов переходов между функциями в интерпретаторе.
    \item Определить набор данных, которые являются самыми востребованными в интерпретаторе и нуждаются в кэшировании в специально выбранных регистрах для уменьшения количества медленных обращений к памяти.
    \item Тестирование полученных результатов для проверки корректности реализации.
\end{enumerate}




\subsection*{Достигнутые результаты}

В рамках данной работы было сконфигурировано окружение, в том числе написаны различные скрипты для упрощения работы с ним, а также реализован генератор RISC-V ассемблера, необходимый для написания порта. Данные результаты, в отличие от по результаты были достигнуты в рамках командной работы.

Были спроектированы структуры фреймов, основанные на нативном ABI C фреймов, что позволило сохранить единообразие системы, необходимое для корректной работы инструментов отладки и Runtime вызовов. Также входной, Java и нативный Java фреймы были реализованы в соответствии со всеми требованиями со стороны системы и нативных соглашений о вызовах. Их структура не подверглась значительным изменениям, в сравнении с другими портами, однако каждое решение по расположению данных на фрейме было обосновано.

Для выбора информации, нуждающейся в кэшированни, было проведено исследование с ручным и автоматическим сборами статистики, как для выявления полезности текущего кэширования данных, выбранного в других портах, так и для потенциального нахождения новых. Данное исследование показало острую необходимость кэширования ряда данных, в то время, как кэширование некоторых других оказалось менее полезным или крайне сомнительным, требующем дальнейшего более индивидуального изучения.

Для тестирования были выбраны несколько подходов, позволяющих, в первую очередь, проверить корректность работы с аргументами на фрейме, в том числе нативными, а также правильность создания и удаления фреймов со стека. Остальные аспекты данной работы не подлежат тщательному тестированию, поэтому их корректность была подтверждена лишь косвенно.

\subsection*{Структура работы}

В обзоре литературы представлены основные для данной работы источники информации в области как архитектуры RISC-V, так и проекта OpenJDK, а также рассмотрены альтернативы по замене литературы, необходимой для портирования OpenJDK.

В первой главе описаны работы по подготовке и настройке рабочего окружения, а также начало процесса портирования, а именно написание генератора ассемблера и печати ошибок JVM.% и неудачные попытки реализации вывода ошибок JVM.

Во второй главе представлены все факторы, учтенные в разработке фреймов, а также описание структур и реализации каждого фрейма.

В третьей главе представлены методы исследования по выбору информации для кэширования, а также полученные в ходе данного исследования результаты. 

В четвертой главе указаны используемые методы тестирования и представлены результаты по общей работе порта на данном этапе его разработки.

В конце работы представлен глоссарий с определениями самых важных терминов, специфичных для данной области.

\renewcommand{\thefigure}{\arabic{section}.\arabic{figure}}