% У заключения нет номера главы
\section*{Заключение}

Главным результатом данной работы является реализация разработанного ABI шаблонного интерпретатора для порта OpenJDK на архитектуру процессора RISC-V. В рамках выполнения поставленной цели были достигнуты следующие задачи:

\begin{enumerate}
    \item Были настроены GNU Toolchain и QEMU эмулятор RISC-V, позволяющие компилировать и запускать проект с помощью специально написанных для этого скриптов, упрощающих всё взаимодействие. Успешность настроенного окружения была проверена посредством запуска zero порта OpenJDK. Был написан генератор RISC-V ассемблера, однако реализация печати ошибок JVM была отложена из-за неполадок в QEMU.
    
    \item При проектировании фреймов были учтены все особенности платформы RISC-V и её нативный ABI, и хоть глобальная структура не изменилась кардинально в сравнении с другими портами, однако каждое решение было принято обоснованно. Реализация генерации фреймов, их заполнения и поддержки были сделаны с учетом необходимости высокой скорости работы приложения.
    
    \item Были разработаны ручная и автоматическая методики сбора данных, которые были применены на порте x86\_64 к трем источникам - инициализации JVM, Renaissance Suite и SPECjvm2008. Наиболее полезными оказались кэширующие регистры bcp, TOS, esp, threads, locals, fp и dispatch\_table. Регистр sender\_sp оказался малополезным, а TOC вовсе неиспользуемым, и от них необходимо избавиться по мере технической возможности.
    
    \item Несмотря на трудность тестирования нерабочего порта OpenJDK, были успешно сгенерированы и пройдены 1289 тестов на различные сигнатуры методов и передачу параметров. Генератор случайных арифметических выражений позволил протестировать работу с локалами. Рабочая часть инициализации Java также доказывает корректность произведенной работы.
\end{enumerate}

В качестве дальнейшей работы над проектом могут быть выполнены работы по расширению и углублению исследования кэширования информации, которые позволят ответить на неразрешенные вопросы о полезности кэширования мониторов и нахождении замены иного малополезного кэширования. Помимо этого, текущий сбор статистики показывает корректные данные только при однопоточном исполнении, что может влиять на показатели для данных, отвечающих за процессы синхронизации, поэтому необходимо найти способ собирать данную статистику в параллельных приложениях. Также остались нереализованными процессы, вызываемые при создании фреймов, необходимые для профилирования и продвинутого сбора статистики исполнения. Общая структура ijava\_state, широко используемая в Runtime вызовах, одновременно содержит информацию, необходимую только в нативных фреймах, а также необходимую только в ненативных, что может быть соптимизировано, если тщательно проанализировать работу интерпретатора с данной структурой и разработать механизм, позволяющий избавиться от лишних данных в обоих случаях, который не помешает текущим процессам исполнения.